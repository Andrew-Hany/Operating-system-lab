--- fork.c	2020-10-07 01:04:13.000000000 +0200
+++ /root/linux/kernel/fork.c	2021-05-18 08:15:33.008729309 +0200
@@ -2385,6 +2385,7 @@
  *
  * args->exit_signal is expected to be checked for sanity by the caller.
  */
+
 long _do_fork(struct kernel_clone_args *args)
 {
 	u64 clone_flags = args->flags;
@@ -2465,7 +2466,107 @@
 	return nr;
 }
 
-/*
+
+//pfork
+
+long sys_pfork(struct kernel_clone_args *args)
+{
+	u64 clone_flags = args->flags;
+	struct completion vfork;
+	struct pid *pid;
+	struct pid *pid2;
+	struct task_struct *p;
+	struct task_struct *p2;
+	int trace = 0;
+	long nr;
+	long nr2;
+
+	/*
+	 * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument
+	 * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are
+	 * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate
+	 * field in struct clone_args and it still doesn't make sense to have
+	 * them both point at the same memory location. Performing this check
+	 * here has the advantage that we don't need to have a separate helper
+	 * to check for legacy clone().
+	 */
+	if ((args->flags & CLONE_PIDFD) &&
+	    (args->flags & CLONE_PARENT_SETTID) &&
+	    (args->pidfd == args->parent_tid))
+		return -EINVAL;
+
+	/*
+	 * Determine whether and which event to report to ptracer.  When
+	 * called from kernel_thread or CLONE_UNTRACED is explicitly
+	 * requested, no event is reported; otherwise, report if the event
+	 * for the type of forking is enabled.
+	 */
+	if (!(clone_flags & CLONE_UNTRACED)) {
+		if (clone_flags & CLONE_VFORK)
+			trace = PTRACE_EVENT_VFORK;
+		else if (args->exit_signal != SIGCHLD)
+			trace = PTRACE_EVENT_CLONE;
+		else
+			trace = PTRACE_EVENT_FORK;
+
+		if (likely(!ptrace_event_enabled(current, trace)))
+			trace = 0;
+	}
+
+	p = copy_process(NULL, trace, NUMA_NO_NODE, args);
+	p->pfork_active_pid=0;
+	p2=copy_process(NULL, trace, NUMA_NO_NODE,args);
+	p2->pfork_standby_pid=0;
+	p->pfork_status=0;
+	p2->pfork_status=0;
+	add_latent_entropy();
+
+	if (IS_ERR(p))
+		return PTR_ERR(p);
+
+	/*
+	 * Do this prior waking up the new thread - the thread pointer
+	 * might get invalid after that point, if the thread exits quickly.
+	 */
+	trace_sched_process_fork(current, p);
+
+	pid = get_task_pid(p, PIDTYPE_PID);
+	pid2=get_task_pid(p2,PIDTYPE_PID);
+
+	nr = pid_vnr(pid);
+	nr2 = pid_vnr(pid2);
+	p->pfork_standby_pid=nr2;
+	p2->pfork_active_pid=nr;
+
+	if (clone_flags & CLONE_PARENT_SETTID)
+		put_user(nr, args->parent_tid);
+
+	if (clone_flags & CLONE_VFORK) {
+		p->vfork_done = &vfork;
+		init_completion(&vfork);
+		get_task_struct(p);
+	}
+
+	wake_up_new_task(p);
+	struct pid *pp=find_vpid(nr2);
+	kill_pid(pp,SIGSTOP,1);
+
+	/* forking complete and child started to run, tell ptracer */
+	if (unlikely(trace))
+		ptrace_event_pid(trace, pid);
+
+	if (clone_flags & CLONE_VFORK) {
+		if (!wait_for_vfork_done(p, &vfork))
+			ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
+	}
+
+	put_pid(pid);
+	return nr;
+}
+
+
+	/*
+	 * Do this prior waking up the new thread - the thread pointer/*
  * Create a kernel thread.
  */
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
@@ -2497,6 +2598,74 @@
 }
 #endif
 
+//pfork
+#ifdef __ARCH_WANT_SYS_PFORK
+SYSCALL_DEFINE0(pfork)
+{
+#ifdef CONFIG_MMU
+	struct kernel_clone_args args = {
+		.exit_signal = SIGCHLD,
+	};
+
+	return sys_pfork(&args);
+#else
+	/* can not support in nommu mode */
+	return -EINVAL;
+#endif
+}
+#endif
+///////////////////
+
+//set_pfork_status
+
+#ifdef __ARCH_WANT_SYS_SET_PFORK_STATUS
+int i;
+SYSCALL_DEFINE1(set_pfork_status,i)
+{
+current->pfork_status=i;
+}
+#endif
+
+/////////
+
+//Get_pfork_status
+
+#ifdef __ARCH_WANT_SYS_GET_PFORK_STATUS
+SYSCALL_DEFINE0(get_pfork_status)
+{
+return current->pfork_status;
+}
+#endif
+//
+
+//get_pfork-sibling_pid
+#ifdef __ARCH_WANT_SYS_GET_PFORK_SIBLING_PID
+SYSCALL_DEFINE0(get_pfork_sibling_pid)
+{
+if(current->pfork_active_pid==0)
+	return current->pfork_standby_pid;
+else if(current->pfork_standby_pid==0)
+	return current->pfork_active_pid;
+}
+#endif
+//
+
+//pfork_who
+#ifdef __ARCH_WANT_SYS_PFORK_WHO
+SYSCALL_DEFINE0(pfork_who)
+{
+if(current->pfork_active_pid==0)
+	return 1;
+else if(current->pfork_standby_pid==0)
+	return 2;
+else
+	return 0;
+}
+#endif
+//
+
+
+
 #ifdef __ARCH_WANT_SYS_VFORK
 SYSCALL_DEFINE0(vfork)
 {
